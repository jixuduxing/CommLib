2014/1/29
目前问题:
1、内存池效率较低，测试结果是默认分配的20分之一左右，因为分配和回收队列都采用的std::deque，该结构也是动态分配的内存，导致效率问题
2、网络库比较简单，异常情况考虑较少，功能也比较简单，考虑在之上实现一个简单易用的网络库+通信协议
3、日志库还未实现

2014/2/7
更详细测试:
1、采用自己编写的list,内存池效率有所提高,大概为默认分配的1/9左右:

1) 99线程,100000任务,每个任务从1到1000字节分配内存:

默认内存分配:
m:8 hm-205794

加锁机制调整后:
m:70 hm112758

耗时操作主要有hash耗时和分配耗时,其中hash耗时9s左右

2) 99线程,100000任务,每个任务从1到10000字节分配内存:
*10:
bithash
m:408 hm-845658
默认hash
m:673 hm190934

默认分配:
m:18 hm52901
m:19 hm-278459

以上测试均为分配之后立即释放的情况

2、
分配的内存暂时不释放,积累到1000块后释放其中600块,然后继续如此如此..
1) 10线程 100个任务 每个1到10000
默认方式:
m:15 hm-765331

内存池方式
m:16 hm-320358

2) 1线程 100 个任务 每个1到10000

内存池方式:
m:8 hm423269
默认方式:
m:9 hm562126

3) 99线程 1000个任务 每个1到10000
默认方式:
m:99 hm164665
内存池方式:
m:115 hm250333

3) 10线程 1000个任务 每个1到10000
内存池
m:152 hm193286

由此可推论:
1、多线程处理上内存池方式不如默认的分配;
2、在大量分配和内存占用中内存池方式的优势会渐渐显现出来,此前并不明显;

2月8日:
memPool测试:
condition:
10 threads 1000 tasks 1 to 10000
积累到1000块后释放其中600块,然后继续如此如此..
1、boost mempool:  每次分配多块内存
m:127 hm325141

2、simple mp by self:
m:145 hm-602605

3、default：
m:132 hm-397664
